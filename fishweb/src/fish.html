<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ¢¦å¹»æµ·æ´‹é±¼ç¾¤</title>
    <style>
      /* å…¨å±€åŸºç¡€æ ·å¼ */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        background: linear-gradient(to bottom, #0a1a3a, #1a4b7a, #2a93d4);
        min-height: 100vh;
        color: white;
        overflow: hidden;
        position: relative;
      }

      /* æµ·æ´‹èƒŒæ™¯å¢å¼º */
      .ocean-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        overflow: hidden;
      }

      /* æ°´æ³¢æ•ˆæœ */
      .water-surface {
        position: absolute;
        width: 100%;
        height: 30%;
        bottom: 0;
        background: linear-gradient(transparent, rgba(32, 156, 238, 0.1));
        animation: waterRipple 8s infinite ease-in-out;
      }

      /* å…‰å½±æ–‘ç‚¹æ¨¡æ‹Ÿæ°´ä¸‹å…‰çº¿ */
      .light-spots {
        position: absolute;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(255, 255, 255, 0.05) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 60%,
            rgba(255, 255, 255, 0.03) 0%,
            transparent 50%
          );
      }

      /* æ ‡é¢˜åŒºåŸŸ */
      .header {
        text-align: center;
        padding: 2.5rem 1rem 2rem;
        z-index: 20;
        position: relative;
        background: rgba(10, 26, 58, 0.5);
        backdrop-filter: blur(3px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      h1 {
        font-size: 3rem;
        font-weight: 300;
        margin-bottom: 0.8rem;
        background: linear-gradient(
          to right,
          #7fffd4,
          #87cefa,
          #98fb98,
          #afeeee
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        text-shadow: 0 2px 15px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        font-size: 1.2rem;
        font-weight: 300;
        color: #d1f0ff;
        margin-bottom: 1.8rem;
        line-height: 1.6;
      }

      /* é±¼ç¾¤ä¿¡æ¯é¢æ¿ */
      .fish-info {
        display: flex;
        justify-content: center;
        gap: 2rem;
        flex-wrap: wrap;
        margin-top: 1.5rem;
      }

      .info-card {
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(5px);
        border-radius: 12px;
        padding: 1rem 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.15);
        min-width: 180px;
      }

      .info-card h3 {
        font-size: 1rem;
        font-weight: 400;
        color: #87ceeb;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .info-card p {
        font-size: 1.8rem;
        font-weight: 300;
        color: #fffacd;
      }

      /* æ“ä½œè¯´æ˜ */
      .instructions {
        text-align: center;
        padding: 1.5rem 1rem;
        font-size: 1.1rem;
        color: #b0e2ff;
        z-index: 20;
        position: relative;
        line-height: 1.8;
      }

      .highlight {
        color: #fffacd;
        font-weight: 500;
      }

      /* æ§åˆ¶é¢æ¿ */
      .controls {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1rem;
        z-index: 1000;
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: white;
        padding: 0.8rem 1.5rem;
        border-radius: 25px;
        cursor: pointer;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      /* é±¼æ ·å¼ */
      .fish {
        position: absolute;
        z-index: 10;
        transition: transform 0.1s linear;
        pointer-events: none;
      }

      .fish-body {
        position: relative;
        width: 100%;
        height: 100%;
      }

      /* é±¼å°¾ - ä¼šæ‘†åŠ¨ */
      .fish-tail {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-style: solid;
        animation: tailSwim 0.5s infinite ease-in-out alternate;
      }

      /* é±¼çœ¼ */
      .fish-eye {
        position: absolute;
        width: 20%;
        height: 20%;
        background: white;
        border-radius: 50%;
        top: 25%;
        left: 20%;
      }

      .fish-eye::after {
        content: "";
        position: absolute;
        width: 50%;
        height: 50%;
        background: black;
        border-radius: 50%;
        top: 25%;
        left: 25%;
      }

      /* ç‚¹å‡»äº§ç”Ÿçš„é£Ÿç‰© */
      .food {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 5;
        filter: blur(1px);
      }

      /* é±¼ç¾¤è½¨è¿¹ï¼ˆå¯é€‰ï¼‰ */
      .trail {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 2;
        opacity: 0.6;
      }

      /* åŠ¨ç”»å®šä¹‰ */
      @keyframes tailSwim {
        0% {
          transform: translateY(-50%) rotate(0deg);
        }
        100% {
          transform: translateY(-50%) rotate(20deg);
        }
      }

      @keyframes waterRipple {
        0%,
        100% {
          transform: translateY(0) scale(1);
          opacity: 0.7;
        }
        50% {
          transform: translateY(-10px) scale(1.02);
          opacity: 1;
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.5);
        }
      }
    </style>
  </head>
  <body>
    <!-- æµ·æ´‹èƒŒæ™¯ -->
    <div class="ocean-bg">
      <div class="light-spots"></div>
      <div class="water-surface"></div>
    </div>

    <!-- æ ‡é¢˜å’Œä¿¡æ¯åŒºåŸŸ -->
    <div class="header">
      <h1>æ·±æµ·é±¼ç¾¤æ¨¡æ‹Ÿ</h1>
      <p class="subtitle">
        åŸºäºBoidsç®—æ³•å®ç°çš„é€¼çœŸé±¼ç¾¤è¡Œä¸ºæ¨¡æ‹Ÿ Â· ç‚¹å‡»æµ·é¢æŠ•æ”¾é£Ÿç‰©å¸å¼•é±¼ç¾¤
      </p>

      <div class="fish-info">
        <div class="info-card">
          <h3>ğŸŸ é±¼ç¾¤æ•°é‡</h3>
          <p id="fishCount">0</p>
        </div>
        <div class="info-card">
          <h3>ğŸ¯ æ´»è·ƒé£Ÿç‰©</h3>
          <p id="foodCount">0</p>
        </div>
        <div class="info-card">
          <h3>ğŸŒŠ é±¼ç¾¤çŠ¶æ€</h3>
          <p id="schoolState">æ¸¸åŠ¨ä¸­</p>
        </div>
      </div>
    </div>

    <!-- æ“ä½œè¯´æ˜ -->
    <div class="instructions">
      <p>
        âœ¨
        <span class="highlight">ç‚¹å‡»æµ·é¢ä»»æ„ä½ç½®</span
        >æŠ•æ”¾é£Ÿç‰©ï¼Œé±¼ç¾¤ä¼šè¢«å¸å¼•è¿‡æ¥è§…é£Ÿ
      </p>
      <p>
        ğŸ 
        é±¼ç¾¤ä¼šè‡ªåŠ¨éµå¾ª<strong>åˆ†ç¦»ã€å¯¹é½ã€èšé›†</strong>ä¸‰ä¸ªåŸºæœ¬è§„åˆ™ï¼Œå½¢æˆè‡ªç„¶ç¾¤è½
      </p>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="controls">
      <button class="control-btn" id="addFishBtn">+ æ·»åŠ å°é±¼</button>
      <button class="control-btn" id="clearFoodBtn">ğŸ§¹ æ¸…é™¤é£Ÿç‰©</button>
      <button class="control-btn" id="toggleTrailsBtn">ğŸ“ˆ è½¨è¿¹å¼€å…³</button>
    </div>

    <!-- é±¼å’Œé£Ÿç‰©çš„å®¹å™¨ -->
    <div id="oceanContainer"></div>

    <script>
      // é±¼ç¾¤æ¨¡æ‹Ÿæ ¸å¿ƒç®—æ³• - Boidsç®—æ³•å®ç°
      class BoidsFishSchool {
        constructor() {
          this.fishes = [];
          this.foods = [];
          this.trails = [];
          this.showTrails = false;
          this.trailLimit = 100;

          // é±¼ç¾¤è¡Œä¸ºå‚æ•°
          this.config = {
            maxSpeed: 2.5, // æœ€å¤§é€Ÿåº¦
            maxForce: 0.05, // æœ€å¤§è½¬å‘åŠ›
            visualRange: 120, // è§†é‡èŒƒå›´
            separationWeight: 1.5, // åˆ†ç¦»æƒé‡ï¼ˆé¿å…ç¢°æ’ï¼‰
            alignmentWeight: 1.0, // å¯¹é½æƒé‡ï¼ˆæ–¹å‘ä¸€è‡´ï¼‰
            cohesionWeight: 1.0, // èšé›†æƒé‡ï¼ˆå‘ä¸­å¿ƒé æ‹¢ï¼‰
            foodAttractionWeight: 1.8, // é£Ÿç‰©å¸å¼•åŠ›æƒé‡
            edgeMargin: 50, // è¾¹ç•Œè·ç¦»
            edgeTurnFactor: 0.5, // è¾¹ç•Œè½¬å‘å› å­
          };

          // é±¼çš„ç±»å‹å’Œé¢œè‰²
          this.fishTypes = [
            { name: "å°ä¸‘é±¼", color: "#FF6B6B", size: 20, speed: 1.0 }, // æ©™è‰²
            { name: "è“å”é±¼", color: "#4ECDC4", size: 24, speed: 0.9 }, // é’è“è‰²
            { name: "é»„é‡‘åŠ", color: "#FFD166", size: 28, speed: 0.8 }, // é‡‘è‰²
            { name: "ç´«ç½—å…°", color: "#9D4EDD", size: 22, speed: 1.1 }, // ç´«è‰²
          ];

          this.container = document.getElementById("oceanContainer");
          this.init();
        }

        init() {
          // åˆå§‹åŒ–é±¼ç¾¤
          this.createInitialFish(15);

          // ç»‘å®šäº‹ä»¶
          this.bindEvents();

          // å¼€å§‹åŠ¨ç”»å¾ªç¯
          this.animate();
        }

        // åˆ›å»ºåˆå§‹é±¼ç¾¤
        createInitialFish(count) {
          for (let i = 0; i < count; i++) {
            this.addFish(
              Math.random() * window.innerWidth,
              Math.random() * window.innerHeight
            );
          }
          this.updateFishCount();
        }

        // æ·»åŠ ä¸€æ¡é±¼
        addFish(x, y) {
          const type =
            this.fishTypes[Math.floor(Math.random() * this.fishTypes.length)];
          const fish = {
            id: this.fishes.length,
            x: x || Math.random() * window.innerWidth,
            y: y || Math.random() * window.innerHeight,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            type: type,
            size: type.size + Math.random() * 8,
            element: null,
            trailHistory: [],
          };

          // åˆ›å»ºé±¼DOMå…ƒç´ 
          const fishEl = document.createElement("div");
          fishEl.className = "fish";
          fishEl.innerHTML = `
                    <div class="fish-body">
                        <div class="fish-tail"></div>
                        <div class="fish-eye"></div>
                    </div>
                `;

          // è®¾ç½®é±¼çš„é¢œè‰²å’Œå¤§å°
          fishEl.style.width = fish.size + "px";
          fishEl.style.height = fish.size / 2 + "px";
          fishEl.style.color = type.color;
          fishEl.querySelector(
            ".fish-tail"
          ).style.borderColor = `transparent transparent transparent ${type.color}`;
          fishEl.querySelector(".fish-tail").style.borderWidth = `${
            fish.size / 4
          }px 0 ${fish.size / 4}px ${fish.size / 2}px`;
          fishEl.style.backgroundColor = type.color;
          fishEl.style.borderRadius = `${fish.size / 2}px ${fish.size / 4}px ${
            fish.size / 4
          }px ${fish.size / 2}px`;

          this.container.appendChild(fishEl);
          fish.element = fishEl;
          this.fishes.push(fish);

          this.updateFishCount();
          return fish;
        }

        // Boidsç®—æ³•æ ¸å¿ƒï¼šåˆ†ç¦»ï¼ˆé¿å…ç¢°æ’ï¼‰
        separation(fish) {
          let steerX = 0;
          let steerY = 0;
          let count = 0;

          for (let other of this.fishes) {
            if (other === fish) continue;

            const dx = fish.x - other.x;
            const dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0 && distance < this.config.visualRange * 0.4) {
              const diffX = dx / distance;
              const diffY = dy / distance;
              steerX += diffX / distance;
              steerY += diffY / distance;
              count++;
            }
          }

          if (count > 0) {
            steerX /= count;
            steerY /= count;

            // è½¬æ¢ä¸ºåŠ›
            const magnitude = Math.sqrt(steerX * steerX + steerY * steerY);
            if (magnitude > 0) {
              steerX = (steerX / magnitude) * this.config.maxSpeed;
              steerY = (steerY / magnitude) * this.config.maxSpeed;

              steerX -= fish.vx;
              steerY -= fish.vy;

              const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
              if (steerMag > this.config.maxForce) {
                steerX = (steerX / steerMag) * this.config.maxForce;
                steerY = (steerY / steerMag) * this.config.maxForce;
              }
            }
          }

          return { x: steerX, y: steerY };
        }

        // Boidsç®—æ³•æ ¸å¿ƒï¼šå¯¹é½ï¼ˆæ–¹å‘ä¸€è‡´ï¼‰
        alignment(fish) {
          let avgVx = 0;
          let avgVy = 0;
          let count = 0;

          for (let other of this.fishes) {
            if (other === fish) continue;

            const dx = fish.x - other.x;
            const dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0 && distance < this.config.visualRange) {
              avgVx += other.vx;
              avgVy += other.vy;
              count++;
            }
          }

          if (count > 0) {
            avgVx /= count;
            avgVy /= count;

            const magnitude = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
            if (magnitude > 0) {
              avgVx = (avgVx / magnitude) * this.config.maxSpeed;
              avgVy = (avgVy / magnitude) * this.config.maxSpeed;

              avgVx -= fish.vx;
              avgVy -= fish.vy;

              const steerMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
              if (steerMag > this.config.maxForce) {
                avgVx = (avgVx / steerMag) * this.config.maxForce;
                avgVy = (avgVy / steerMag) * this.config.maxForce;
              }
            }
          }

          return { x: avgVx, y: avgVy };
        }

        // Boidsç®—æ³•æ ¸å¿ƒï¼šèšé›†ï¼ˆå‘ä¸­å¿ƒé æ‹¢ï¼‰
        cohesion(fish) {
          let centerX = 0;
          let centerY = 0;
          let count = 0;

          for (let other of this.fishes) {
            if (other === fish) continue;

            const dx = fish.x - other.x;
            const dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0 && distance < this.config.visualRange) {
              centerX += other.x;
              centerY += other.y;
              count++;
            }
          }

          if (count > 0) {
            centerX /= count;
            centerY /= count;

            let desiredX = centerX - fish.x;
            let desiredY = centerY - fish.y;

            const dist = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
            if (dist > 0) {
              desiredX = (desiredX / dist) * this.config.maxSpeed;
              desiredY = (desiredY / dist) * this.config.maxSpeed;

              desiredX -= fish.vx;
              desiredY -= fish.vy;

              const steerMag = Math.sqrt(
                desiredX * desiredX + desiredY * desiredY
              );
              if (steerMag > this.config.maxForce) {
                desiredX = (desiredX / steerMag) * this.config.maxForce;
                desiredY = (desiredY / steerMag) * this.config.maxForce;
              }
            }

            return { x: desiredX, y: desiredY };
          }

          return { x: 0, y: 0 };
        }

        // é£Ÿç‰©å¸å¼•åŠ›
        foodAttraction(fish) {
          if (this.foods.length === 0) return { x: 0, y: 0 };

          let closestFood = null;
          let closestDist = Infinity;

          for (let food of this.foods) {
            const dx = food.x - fish.x;
            const dy = food.y - fish.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < closestDist && distance < 300) {
              closestDist = distance;
              closestFood = food;
            }
          }

          if (!closestFood) return { x: 0, y: 0 };

          let desiredX = closestFood.x - fish.x;
          let desiredY = closestFood.y - fish.y;
          const dist = Math.sqrt(desiredX * desiredX + desiredY * desiredY);

          if (dist > 0) {
            // ç¦»é£Ÿç‰©è¶Šè¿‘ï¼Œé€Ÿåº¦è¶Šæ…¢
            const speed = this.config.maxSpeed * Math.min(dist / 100, 1);
            desiredX = (desiredX / dist) * speed;
            desiredY = (desiredY / dist) * speed;

            desiredX -= fish.vx;
            desiredY -= fish.vy;

            const steerMag = Math.sqrt(
              desiredX * desiredX + desiredY * desiredY
            );
            if (steerMag > this.config.maxForce * 2) {
              desiredX = (desiredX / steerMag) * this.config.maxForce * 2;
              desiredY = (desiredY / steerMag) * this.config.maxForce * 2;
            }

            return { x: desiredX, y: desiredY };
          }

          return { x: 0, y: 0 };
        }

        // è¾¹ç•Œå¤„ç†
        checkBounds(fish) {
          const turnForce = this.config.edgeTurnFactor;
          let forceX = 0,
            forceY = 0;

          if (fish.x < this.config.edgeMargin) {
            forceX = turnForce;
          } else if (fish.x > window.innerWidth - this.config.edgeMargin) {
            forceX = -turnForce;
          }

          if (fish.y < this.config.edgeMargin) {
            forceY = turnForce;
          } else if (fish.y > window.innerHeight - this.config.edgeMargin) {
            forceY = -turnForce;
          }

          return { x: forceX, y: forceY };
        }

        // æ›´æ–°é±¼çš„çŠ¶æ€
        updateFish(fish) {
          // è®¡ç®—å„ç§åŠ›
          const sep = this.separation(fish);
          const ali = this.alignment(fish);
          const coh = this.cohesion(fish);
          const food = this.foodAttraction(fish);
          const bounds = this.checkBounds(fish);

          // åº”ç”¨åŠ æƒåŠ›
          fish.vx +=
            sep.x * this.config.separationWeight +
            ali.x * this.config.alignmentWeight +
            coh.x * this.config.cohesionWeight +
            food.x * this.config.foodAttractionWeight +
            bounds.x;

          fish.vy +=
            sep.y * this.config.separationWeight +
            ali.y * this.config.alignmentWeight +
            coh.y * this.config.cohesionWeight +
            food.y * this.config.foodAttractionWeight +
            bounds.y;

          // é™åˆ¶é€Ÿåº¦
          const speed = Math.sqrt(fish.vx * fish.vx + fish.vy * fish.vy);
          if (speed > this.config.maxSpeed) {
            fish.vx = (fish.vx / speed) * this.config.maxSpeed;
            fish.vy = (fish.vy / speed) * this.config.maxSpeed;
          }

          // æ›´æ–°ä½ç½®
          fish.x += fish.vx;
          fish.y += fish.vy;

          // è®°å½•è½¨è¿¹
          if (this.showTrails) {
            fish.trailHistory.push({ x: fish.x, y: fish.y });
            if (fish.trailHistory.length > 5) {
              fish.trailHistory.shift();
            }
          }

          // æ›´æ–°DOMå…ƒç´ 
          this.updateFishElement(fish);
        }

        // æ›´æ–°é±¼çš„DOMå…ƒç´ 
        updateFishElement(fish) {
          if (!fish.element) return;

          // è®¡ç®—è§’åº¦
          const angle = (Math.atan2(fish.vy, fish.vx) * 180) / Math.PI;

          // æ›´æ–°ä½ç½®å’Œæ—‹è½¬
          fish.element.style.transform = `translate(${fish.x}px, ${fish.y}px) rotate(${angle}deg)`;
          fish.element.style.left = "0";
          fish.element.style.top = "0";
        }

        // æ·»åŠ é£Ÿç‰©
        addFood(x, y) {
          const food = {
            x: x,
            y: y,
            createdAt: Date.now(),
            lifespan: 8000, // 8ç§’åæ¶ˆå¤±
            element: null,
          };

          const foodEl = document.createElement("div");
          foodEl.className = "food";
          foodEl.style.left = x + "px";
          foodEl.style.top = y + "px";
          foodEl.style.backgroundColor = `hsl(${
            Math.random() * 60 + 40
          }, 100%, 70%)`;
          foodEl.style.boxShadow = `0 0 15px 5px hsl(${
            Math.random() * 60 + 40
          }, 100%, 70%)`;

          this.container.appendChild(foodEl);
          food.element = foodEl;
          this.foods.push(food);

          // é£Ÿç‰©æ·¡å‡ºåŠ¨ç”»
          setTimeout(() => {
            if (food.element && food.element.parentNode) {
              food.element.style.animation = "fadeOut 0.5s forwards";
              setTimeout(() => {
                if (food.element && food.element.parentNode) {
                  food.element.remove();
                }
              }, 500);
            }
          }, food.lifespan - 500);

          this.updateFoodCount();
          return food;
        }

        // æ¸…ç†è¿‡æœŸé£Ÿç‰©
        cleanupFoods() {
          const now = Date.now();
          for (let i = this.foods.length - 1; i >= 0; i--) {
            const food = this.foods[i];
            if (now - food.createdAt > food.lifespan) {
              if (food.element && food.element.parentNode) {
                food.element.remove();
              }
              this.foods.splice(i, 1);
            }
          }
          this.updateFoodCount();
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateFishCount() {
          document.getElementById("fishCount").textContent = this.fishes.length;
        }

        updateFoodCount() {
          document.getElementById("foodCount").textContent = this.foods.length;
          const stateEl = document.getElementById("schoolState");
          if (this.foods.length > 0) {
            stateEl.textContent = "è§…é£Ÿä¸­";
            stateEl.style.color = "#FFD700";
          } else {
            stateEl.textContent = "æ¸¸åŠ¨ä¸­";
            stateEl.style.color = "#98FB98";
          }
        }

        // æ¸…é™¤æ‰€æœ‰é£Ÿç‰©
        clearAllFoods() {
          this.foods.forEach((food) => {
            if (food.element && food.element.parentNode) {
              food.element.remove();
            }
          });
          this.foods = [];
          this.updateFoodCount();
        }

        // ç»‘å®šäº‹ä»¶
        bindEvents() {
          // ç‚¹å‡»æ·»åŠ é£Ÿç‰©
          document.addEventListener("click", (e) => {
            if (e.target.tagName === "BUTTON") return;
            this.addFood(e.clientX, e.clientY);

            // æ·»åŠ å¤šä¸ªé£Ÿç‰©ç‚¹ï¼Œæ›´è‡ªç„¶
            for (let i = 0; i < 3; i++) {
              setTimeout(() => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 30;
                this.addFood(
                  e.clientX + Math.cos(angle) * distance,
                  e.clientY + Math.sin(angle) * distance
                );
              }, i * 100);
            }
          });

          // æ§åˆ¶æŒ‰é’®
          document
            .getElementById("addFishBtn")
            .addEventListener("click", () => {
              this.addFish();
            });

          document
            .getElementById("clearFoodBtn")
            .addEventListener("click", () => {
              this.clearAllFoods();
            });

          document
            .getElementById("toggleTrailsBtn")
            .addEventListener("click", () => {
              this.showTrails = !this.showTrails;
              const btn = document.getElementById("toggleTrailsBtn");
              btn.textContent = this.showTrails ? "ğŸ“ˆ å…³é—­è½¨è¿¹" : "ğŸ“ˆ æ˜¾ç¤ºè½¨è¿¹";
            });

          // çª—å£å¤§å°è°ƒæ•´
          window.addEventListener("resize", () => {
            // ç¡®ä¿é±¼ä¸å‡ºç•Œ
            this.fishes.forEach((fish) => {
              fish.x = Math.max(0, Math.min(fish.x, window.innerWidth));
              fish.y = Math.max(0, Math.min(fish.y, window.innerHeight));
            });
          });
        }

        // åŠ¨ç”»å¾ªç¯
        animate() {
          // æ›´æ–°æ¯æ¡é±¼
          this.fishes.forEach((fish) => this.updateFish(fish));

          // æ¸…ç†è¿‡æœŸé£Ÿç‰©
          this.cleanupFoods();

          // ç»§ç»­åŠ¨ç”»å¾ªç¯
          requestAnimationFrame(() => this.animate());
        }
      }

      // é¡µé¢åŠ è½½ååˆå§‹åŒ–é±¼ç¾¤
      window.addEventListener("load", () => {
        const fishSchool = new BoidsFishSchool();

        // æ·»åŠ ä¸€äº›åˆå§‹é£Ÿç‰©
        setTimeout(() => {
          for (let i = 0; i < 3; i++) {
            fishSchool.addFood(
              window.innerWidth * 0.3 + Math.random() * window.innerWidth * 0.4,
              window.innerHeight * 0.3 +
                Math.random() * window.innerHeight * 0.4
            );
          }
        }, 1000);
      });
    </script>
  </body>
</html>
