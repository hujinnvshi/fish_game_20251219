<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æµ·æ´‹ç”Ÿæ€ç³»ç»Ÿæ¨¡æ‹Ÿ</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        background: linear-gradient(to bottom, #0a1a3a, #1a4b7a, #2a93d4);
        min-height: 100vh;
        color: white;
        overflow: hidden;
        position: relative;
      }

      .ocean-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        overflow: hidden;
      }

      .water-surface {
        position: absolute;
        width: 100%;
        height: 30%;
        bottom: 0;
        background: linear-gradient(transparent, rgba(32, 156, 238, 0.1));
        animation: waterRipple 8s infinite ease-in-out;
      }

      .light-spots {
        position: absolute;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 30%,
            rgba(255, 255, 255, 0.05) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 60%,
            rgba(255, 255, 255, 0.03) 0%,
            transparent 50%
          );
      }

      .header {
        text-align: center;
        padding: 2rem 1rem 1.5rem;
        z-index: 20;
        position: relative;
        background: rgba(10, 26, 58, 0.5);
        backdrop-filter: blur(3px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      h1 {
        font-size: 2.5rem;
        font-weight: 300;
        margin-bottom: 0.5rem;
        background: linear-gradient(
          to right,
          #7fffd4,
          #87cefa,
          #98fb98,
          #afeeee
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .subtitle {
        font-size: 1.1rem;
        color: #d1f0ff;
        margin-bottom: 1.5rem;
      }

      /* ç”Ÿæ€ç³»ç»Ÿä¿¡æ¯é¢æ¿ */
      .ecosystem-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        max-width: 1000px;
        margin: 0 auto;
        padding: 0 1rem;
      }

      .info-card {
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(5px);
        border-radius: 12px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.15);
      }

      .info-card h3 {
        font-size: 0.9rem;
        color: #87ceeb;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .info-card p {
        font-size: 1.5rem;
        font-weight: 300;
        color: #fffacd;
      }

      /* é±¼ç±»å›¾é‰´ */
      .fish-encyclopedia {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        margin-top: 1rem;
        flex-wrap: wrap;
      }

      .fish-species {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        font-size: 0.9rem;
      }

      .species-icon {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      /* æ§åˆ¶é¢æ¿ */
      .controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1rem;
        z-index: 1000;
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: white;
        padding: 0.7rem 1.2rem;
        border-radius: 20px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      /* é±¼æ ·å¼ */
      .fish {
        position: absolute;
        z-index: 10;
        transition: transform 0.1s linear;
        pointer-events: none;
      }

      .fish-body {
        position: relative;
        width: 100%;
        height: 100%;
      }

      .fish-tail {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-style: solid;
        animation: tailSwim 0.5s infinite ease-in-out alternate;
      }

      .fish-eye {
        position: absolute;
        width: 20%;
        height: 20%;
        background: white;
        border-radius: 50%;
        top: 25%;
        left: 20%;
      }

      .fish-eye::after {
        content: "";
        position: absolute;
        width: 50%;
        height: 50%;
        background: black;
        border-radius: 50%;
        top: 25%;
        left: 25%;
      }

      /* é£Ÿç‰©æ ·å¼ */
      .food {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 5;
        filter: blur(1px);
      }

      /* é±¼å¤§å°æ ‡ç­¾ */
      .size-indicator {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.8);
        white-space: nowrap;
      }

      /* åŠ¨ç”» */
      @keyframes tailSwim {
        0% {
          transform: translateY(-50%) rotate(0deg);
        }
        100% {
          transform: translateY(-50%) rotate(20deg);
        }
      }

      @keyframes waterRipple {
        0%,
        100% {
          transform: translateY(0) scale(1);
          opacity: 0.7;
        }
        50% {
          transform: translateY(-10px) scale(1.02);
          opacity: 1;
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.5);
        }
      }

      @keyframes grow {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.1);
        }
      }

      @keyframes shrink {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(0.9);
        }
      }
    </style>
  </head>
  <body>
    <!-- æµ·æ´‹èƒŒæ™¯ -->
    <div class="ocean-bg">
      <div class="light-spots"></div>
      <div class="water-surface"></div>
    </div>

    <!-- æ ‡é¢˜å’Œä¿¡æ¯åŒºåŸŸ -->
    <div class="header">
      <h1>æµ·æ´‹ç”Ÿæ€ç³»ç»Ÿæ¨¡æ‹Ÿ</h1>
      <p class="subtitle">åŸºäºBoidsç®—æ³• Â· åŒ…å«é£Ÿç‰©é“¾ã€ç”Ÿå­˜ç«äº‰å’ŒåŠ¨æ€ç”Ÿé•¿ç³»ç»Ÿ</p>

      <div class="ecosystem-panel">
        <div class="info-card">
          <h3>ğŸŸ ç°å­˜é±¼ç±»</h3>
          <p id="fishCount">0</p>
        </div>
        <div class="info-card">
          <h3>ğŸ½ï¸ æ´»è·ƒé£Ÿç‰©</h3>
          <p id="foodCount">0</p>
        </div>
        <div class="info-card">
          <h3>âš–ï¸ é£Ÿç‰©é“¾å±‚çº§</h3>
          <p id="foodChainLevel">3</p>
        </div>
        <div class="info-card">
          <h3>ğŸ“ˆ å¹³å‡ä½“å‹</h3>
          <p id="avgSize">1.0x</p>
        </div>
      </div>

      <!-- é±¼ç±»å›¾é‰´ -->
      <div class="fish-encyclopedia">
        <div class="fish-species">
          <div class="species-icon" style="background-color: #ff6b6b"></div>
          <span>å°ä¸‘é±¼ (è‰é£Ÿ)</span>
        </div>
        <div class="fish-species">
          <div class="species-icon" style="background-color: #4ecdc4"></div>
          <span>è“å”é±¼ (æ‚é£Ÿ)</span>
        </div>
        <div class="fish-species">
          <div class="species-icon" style="background-color: #ffd166"></div>
          <span>é»„é‡‘åŠ (è‚‰é£Ÿ)</span>
        </div>
        <div class="fish-species">
          <div class="species-icon" style="background-color: #9d4edd"></div>
          <span>ç´«ç½—å…°é±¼ (é¡¶çº§æ é£Ÿ)</span>
        </div>
      </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="controls">
      <button class="control-btn" id="addFishBtn">+ æ·»åŠ é±¼</button>
      <button class="control-btn" id="addFoodBtn">ğŸ½ï¸ æ‰¹é‡æŠ•é£Ÿ</button>
      <button class="control-btn" id="clearFoodBtn">ğŸ§¹ æ¸…ç†é£Ÿç‰©</button>
      <button class="control-btn" id="resetBtn">ğŸ”„ é‡ç½®ç³»ç»Ÿ</button>
    </div>

    <!-- é±¼å’Œé£Ÿç‰©çš„å®¹å™¨ -->
    <div id="oceanContainer"></div>

    <script>
      class MarineEcosystem {
        constructor() {
          this.fishes = []; // æ‰€æœ‰é±¼ç±»
          this.foods = []; // æ‰€æœ‰é£Ÿç‰©
          this.deadFish = []; // æ­»äº¡è®°å½•
          this.eatenCount = 0; // è¢«åƒè®¡æ•°

          // ç”Ÿæ€ç³»ç»Ÿå‚æ•°
          this.config = {
            maxSpeed: 2.5,
            maxForce: 0.05,
            visualRange: 120,
            separationWeight: 1.5,
            alignmentWeight: 1.0,
            cohesionWeight: 1.0,
            foodAttractionWeight: 2.0,
            edgeMargin: 50,
            edgeTurnFactor: 0.5,

            // æ–°å¢ï¼šç”Ÿé•¿å’Œç”Ÿå­˜å‚æ•°
            baseMetabolism: 0.0005, // åŸºç¡€ä»£è°¢ç‡ï¼ˆä½“å‹å‡å°‘é€Ÿåº¦ï¼‰
            hungerThreshold: 5, // é¥¥é¥¿é˜ˆå€¼ï¼ˆç§’ï¼‰
            starveThreshold: 20, // é¥¿æ­»é˜ˆå€¼ï¼ˆç§’ï¼‰
            growthRate: 0.1, // æ¯åƒä¸€ä¸ªé£Ÿç‰©çš„ç”Ÿé•¿é‡
            shrinkRate: 0.05, // æ¯æ¬¡æŒ¨é¥¿çš„æ”¶ç¼©é‡
            minSize: 0.5, // æœ€å°ä½“å‹æ¯”ä¾‹
            maxSize: 3.0, // æœ€å¤§ä½“å‹æ¯”ä¾‹
            eatDistance: 15, // æ•é£Ÿè·ç¦»
            reproductionChance: 0.01, // ç¹æ®–æ¦‚ç‡
          };

          // é±¼ç±»å®šä¹‰ï¼ˆé£Ÿç‰©é“¾å±‚çº§ã€é£Ÿæ€§ã€é¢œè‰²ã€åŸºç¡€å±æ€§ï¼‰
          this.fishSpecies = [
            {
              name: "å°ä¸‘é±¼",
              color: "#FF6B6B",
              baseSize: 20,
              speed: 1.0,
              diet: "herbivore", // é£Ÿè‰
              foodChain: 1, // é£Ÿç‰©é“¾å±‚çº§
              canEat: [], // ä¸èƒ½åƒå…¶ä»–é±¼
            },
            {
              name: "è“å”é±¼",
              color: "#4ECDC4",
              baseSize: 24,
              speed: 0.9,
              diet: "omnivore", // æ‚é£Ÿ
              foodChain: 2,
              canEat: [1], // èƒ½åƒå±‚çº§1çš„é±¼
            },
            {
              name: "é»„é‡‘åŠ",
              color: "#FFD166",
              baseSize: 28,
              speed: 0.8,
              diet: "carnivore", // è‚‰é£Ÿ
              foodChain: 3,
              canEat: [1, 2], // èƒ½åƒå±‚çº§1-2çš„é±¼
            },
            {
              name: "ç´«ç½—å…°é±¼",
              color: "#9D4EDD",
              baseSize: 22,
              speed: 1.1,
              diet: "apex", // é¡¶çº§æ é£Ÿ
              foodChain: 4,
              canEat: [1, 2, 3], // èƒ½åƒæ‰€æœ‰ä½å±‚çº§é±¼
            },
          ];

          this.container = document.getElementById("oceanContainer");
          this.lastUpdateTime = Date.now();
          this.init();
        }

        init() {
          this.createInitialFish(20);
          this.bindEvents();
          this.updateStats();
          this.animate();
        }

        // åˆ›å»ºåˆå§‹é±¼ç¾¤
        createInitialFish(count) {
          for (let i = 0; i < count; i++) {
            this.addRandomFish();
          }
        }

        // æ·»åŠ éšæœºé±¼
        addRandomFish(x, y) {
          const speciesIndex = Math.floor(
            Math.random() * this.fishSpecies.length
          );
          const species = this.fishSpecies[speciesIndex];

          const fish = {
            id: Date.now() + Math.random(),
            x: x || Math.random() * window.innerWidth,
            y: y || Math.random() * window.innerHeight,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            species: species,
            speciesIndex: speciesIndex,

            // ç”Ÿé•¿ç›¸å…³å±æ€§
            size: 1.0, // å½“å‰ä½“å‹å€æ•°
            hunger: 0, // é¥¥é¥¿å€¼ï¼ˆ0-1ï¼‰
            lastEatTime: Date.now(), // ä¸Šæ¬¡è¿›é£Ÿæ—¶é—´
            health: 1.0, // å¥åº·åº¦
            isStarving: false, // æ˜¯å¦å¤„äºé¥¥é¥¿çŠ¶æ€

            // è§†è§‰å…ƒç´ 
            element: null,
            sizeLabel: null,
          };

          this.createFishElement(fish);
          this.fishes.push(fish);
          this.updateFishCount();
          return fish;
        }

        // åˆ›å»ºé±¼DOMå…ƒç´ 
        createFishElement(fish) {
          const fishEl = document.createElement("div");
          fishEl.className = "fish";
          fishEl.innerHTML = `
                    <div class="fish-body">
                        <div class="fish-tail"></div>
                        <div class="fish-eye"></div>
                    </div>
                `;

          this.updateFishAppearance(fish, fishEl);
          this.container.appendChild(fishEl);
          fish.element = fishEl;

          // åˆ›å»ºä½“å‹æ ‡ç­¾
          const sizeLabel = document.createElement("div");
          sizeLabel.className = "size-indicator";
          fishEl.appendChild(sizeLabel);
          fish.sizeLabel = sizeLabel;
        }

        // æ›´æ–°é±¼çš„å¤–è§‚
        updateFishAppearance(fish, element = fish.element) {
          if (!element) return;

          const actualSize = fish.species.baseSize * fish.size;
          element.style.width = actualSize + "px";
          element.style.height = actualSize / 2 + "px";
          element.style.color = fish.species.color;
          element.style.backgroundColor = fish.species.color;

          // è®¾ç½®é±¼å°¾
          const tail = element.querySelector(".fish-tail");
          tail.style.borderColor = `transparent transparent transparent ${fish.species.color}`;
          tail.style.borderWidth = `${actualSize / 4}px 0 ${actualSize / 4}px ${
            actualSize / 2
          }px`;

          // è®¾ç½®åœ†è§’
          element.style.borderRadius = `${actualSize / 2}px ${
            actualSize / 4
          }px ${actualSize / 4}px ${actualSize / 2}px`;

          // æ›´æ–°ä½“å‹æ˜¾ç¤º
          if (fish.sizeLabel) {
            fish.sizeLabel.textContent = `x${fish.size.toFixed(1)}`;

            // æ ¹æ®å¥åº·çŠ¶å†µæ”¹å˜é¢œè‰²
            if (fish.health < 0.3) {
              fish.sizeLabel.style.color = "#ff6b6b";
            } else if (fish.isStarving) {
              fish.sizeLabel.style.color = "#ffa726";
            } else {
              fish.sizeLabel.style.color = "rgba(255, 255, 255, 0.8)";
            }
          }

          // é¥¥é¥¿çŠ¶æ€æ•ˆæœ
          if (fish.isStarving) {
            element.style.opacity = 0.7;
          } else {
            element.style.opacity = 1;
          }
        }

        // æ·»åŠ é£Ÿç‰©
        addFood(x, y, isFish = false) {
          const food = {
            x: x,
            y: y,
            createdAt: Date.now(),
            lifespan: 8000,
            isFish: isFish, // æ˜¯å¦æ˜¯é±¼å°¸ä½“
            nutrition: isFish ? 3 : 1, // é±¼å°¸ä½“æä¾›æ›´å¤šè¥å…»
            element: null,
          };

          const foodEl = document.createElement("div");
          foodEl.className = "food";
          foodEl.style.left = x + "px";
          foodEl.style.top = y + "px";

          if (isFish) {
            // é±¼å°¸ä½“æ˜¯çº¢è‰²çš„
            foodEl.style.backgroundColor = "#ff4444";
            foodEl.style.boxShadow = "0 0 20px 8px #ff4444";
            foodEl.style.width = "12px";
            foodEl.style.height = "12px";
          } else {
            // æ™®é€šé£Ÿç‰©
            const hue = Math.random() * 60 + 40;
            foodEl.style.backgroundColor = `hsl(${hue}, 100%, 70%)`;
            foodEl.style.boxShadow = `0 0 15px 5px hsl(${hue}, 100%, 70%)`;
          }

          this.container.appendChild(foodEl);
          food.element = foodEl;
          this.foods.push(food);

          // è®¾ç½®é£Ÿç‰©æ¶ˆå¤±åŠ¨ç”»
          setTimeout(() => {
            if (food.element && food.element.parentNode) {
              food.element.style.animation = "fadeOut 0.5s forwards";
              setTimeout(() => {
                if (food.element && food.element.parentNode) {
                  food.element.remove();
                }
              }, 500);
            }
          }, food.lifespan - 500);

          this.updateFoodCount();
        }

        // æ¸…ç†è¿‡æœŸé£Ÿç‰©
        cleanupFoods() {
          const now = Date.now();
          for (let i = this.foods.length - 1; i >= 0; i--) {
            const food = this.foods[i];
            if (now - food.createdAt > food.lifespan) {
              this.removeFood(i);
            }
          }
        }

        removeFood(index) {
          const food = this.foods[index];
          if (food.element && food.element.parentNode) {
            food.element.remove();
          }
          this.foods.splice(index, 1);
          this.updateFoodCount();
        }

        // é±¼æ•é£Ÿå…¶ä»–é±¼
        tryEatOtherFish(fish) {
          // åªæœ‰è‚‰é£Ÿæ€§å’Œé¡¶çº§æ é£Ÿè€…èƒ½æ•é£Ÿ
          if (
            fish.species.diet !== "carnivore" &&
            fish.species.diet !== "apex"
          ) {
            return false;
          }

          for (let i = this.fishes.length - 1; i >= 0; i--) {
            const other = this.fishes[i];
            if (other === fish) continue;

            // æ£€æŸ¥æ˜¯å¦èƒ½åƒï¼ˆé£Ÿç‰©é“¾å±‚çº§ï¼‰
            if (!fish.species.canEat.includes(other.species.foodChain))
              continue;

            // æ£€æŸ¥ä½“å‹å·®å¼‚ï¼ˆåªèƒ½åƒä½“å‹å°äºè‡ªå·±çš„é±¼ï¼‰
            if (other.size >= fish.size) continue;

            // æ£€æŸ¥è·ç¦»
            const dx = other.x - fish.x;
            const dy = other.y - fish.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.config.eatDistance * fish.size) {
              // åƒæ‰å…¶ä»–é±¼
              this.eatFish(fish, other, i);
              return true;
            }
          }
          return false;
        }

        // æ‰§è¡Œæ•é£Ÿ
        eatFish(predator, prey, preyIndex) {
          // ä»åœºæ™¯ä¸­ç§»é™¤è¢«åƒçš„é±¼
          if (prey.element && prey.element.parentNode) {
            prey.element.remove();
          }
          this.fishes.splice(preyIndex, 1);

          // è®°å½•ç»Ÿè®¡
          this.deadFish.push({
            predator: predator.species.name,
            prey: prey.species.name,
            time: Date.now(),
          });
          this.eatenCount++;

          // æ•é£Ÿè€…ç”Ÿé•¿
          this.growFish(predator, prey.size * 0.5);

          // ç”Ÿæˆé±¼å°¸ä½“ä½œä¸ºé£Ÿç‰©
          this.addFood(prey.x, prey.y, true);

          console.log(`${predator.species.name} åƒæ‰äº† ${prey.species.name}`);
        }

        // é±¼åƒé£Ÿç‰©
        tryEatFood(fish) {
          for (let i = this.foods.length - 1; i >= 0; i--) {
            const food = this.foods[i];
            const dx = food.x - fish.x;
            const dy = food.y - fish.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.config.eatDistance * fish.size) {
              // åƒé£Ÿç‰©
              fish.lastEatTime = Date.now();
              fish.hunger = 0;
              fish.isStarving = false;

              // æ ¹æ®é£Ÿç‰©ç±»å‹ç”Ÿé•¿
              this.growFish(fish, food.nutrition * 0.1);

              // ç§»é™¤é£Ÿç‰©
              this.removeFood(i);

              // åƒé£Ÿç‰©åŠ¨ç”»
              if (fish.element) {
                fish.element.style.animation = "grow 0.2s ease-in-out";
                setTimeout(() => {
                  if (fish.element) {
                    fish.element.style.animation = "";
                  }
                }, 200);
              }

              return true;
            }
          }
          return false;
        }

        // é±¼ç”Ÿé•¿
        growFish(fish, amount) {
          const oldSize = fish.size;
          fish.size = Math.min(this.config.maxSize, fish.size + amount);

          // æ›´æ–°å¤–è§‚
          this.updateFishAppearance(fish);

          // æ£€æŸ¥ç¹æ®–
          if (
            oldSize < 1.5 &&
            fish.size >= 1.5 &&
            Math.random() < this.config.reproductionChance
          ) {
            this.reproduceFish(fish);
          }
        }

        // é±¼ç¹æ®–
        reproduceFish(parent) {
          const child = this.addRandomFish(parent.x + 30, parent.y + 30);
          child.size = 0.8; // å¹¼é±¼è¾ƒå°
          this.updateFishAppearance(child);
          console.log(`${parent.species.name} ç¹æ®–äº†ï¼`);
        }

        // é±¼æŒ¨é¥¿ï¼ˆä½“å‹å‡å°ï¼‰
        starveFish(fish, deltaTime) {
          const starveTime = (Date.now() - fish.lastEatTime) / 1000;

          if (starveTime > this.config.hungerThreshold) {
            fish.isStarving = true;

            if (starveTime > this.config.starveThreshold) {
              // å¥åº·åº¦ä¸‹é™
              fish.health = Math.max(0, fish.health - 0.001 * deltaTime);
            }

            // ä½“å‹ç¼©å°
            fish.size = Math.max(
              this.config.minSize,
              fish.size - this.config.baseMetabolism * deltaTime
            );

            // æ›´æ–°å¤–è§‚
            this.updateFishAppearance(fish);

            // é¥¿æ­»
            if (fish.size <= this.config.minSize + 0.1) {
              this.killFish(fish);
              return;
            }

            // æŒ¨é¥¿åŠ¨ç”»
            if (fish.health < 0.5 && fish.element) {
              fish.element.style.animation =
                "shrink 0.5s ease-in-out infinite alternate";
            }
          } else {
            fish.isStarving = false;
            if (fish.element) {
              fish.element.style.animation = "";
            }
          }
        }

        // ç§»é™¤æ­»é±¼
        killFish(fish) {
          const index = this.fishes.indexOf(fish);
          if (index !== -1) {
            // åˆ›å»ºé±¼å°¸ä½“é£Ÿç‰©
            this.addFood(fish.x, fish.y, true);

            // ç§»é™¤é±¼å…ƒç´ 
            if (fish.element && fish.element.parentNode) {
              fish.element.remove();
            }
            this.fishes.splice(index, 1);

            console.log(`${fish.species.name} é¥¿æ­»äº†`);
          }
        }

        // Boidsç®—æ³•æ ¸å¿ƒï¼ˆç®€åŒ–ç‰ˆï¼ŒåŒ…å«åŸºç¡€è¡Œä¸ºï¼‰
        updateFishBehavior(fish, deltaTime) {
          // åŸºç¡€è¡Œä¸ºï¼šåˆ†ç¦»ã€å¯¹é½ã€èšé›†
          const sep = this.separation(fish);
          const ali = this.alignment(fish);
          const coh = this.cohesion(fish);
          const bounds = this.checkBounds(fish);

          // é£Ÿç‰©å¸å¼•åŠ›
          let foodForce = { x: 0, y: 0 };
          if (this.foods.length > 0 && fish.isStarving) {
            foodForce = this.foodAttraction(fish);
          }

          // åº”ç”¨æ‰€æœ‰åŠ›
          fish.vx +=
            sep.x * this.config.separationWeight +
            ali.x * this.config.alignmentWeight +
            coh.x * this.config.cohesionWeight +
            foodForce.x +
            bounds.x;

          fish.vy +=
            sep.y * this.config.separationWeight +
            ali.y * this.config.alignmentWeight +
            coh.y * this.config.cohesionWeight +
            foodForce.y +
            bounds.y;

          // ä½“å‹å½±å“é€Ÿåº¦
          const speedMultiplier = 1 / fish.size;
          const maxSpeed = this.config.maxSpeed * speedMultiplier;

          // é™åˆ¶é€Ÿåº¦
          const speed = Math.sqrt(fish.vx * fish.vx + fish.vy * fish.vy);
          if (speed > maxSpeed) {
            fish.vx = (fish.vx / speed) * maxSpeed;
            fish.vy = (fish.vy / speed) * maxSpeed;
          }

          // æ›´æ–°ä½ç½®
          fish.x += fish.vx;
          fish.y += fish.vy;

          // æ›´æ–°DOM
          this.updateFishElement(fish);

          // å¤„ç†é¥¥é¥¿
          this.starveFish(fish, deltaTime);
        }

        // æ›´æ–°é±¼çš„ä½ç½®å’Œæ—‹è½¬
        updateFishElement(fish) {
          if (!fish.element) return;

          const angle = (Math.atan2(fish.vy, fish.vx) * 180) / Math.PI;
          fish.element.style.transform = `translate(${fish.x}px, ${fish.y}px) rotate(${angle}deg)`;
          fish.element.style.left = "0";
          fish.element.style.top = "0";
        }

        // åŠ¨ç”»å¾ªç¯
        animate() {
          const now = Date.now();
          const deltaTime = now - this.lastUpdateTime;
          this.lastUpdateTime = now;

          // æ›´æ–°æ¯æ¡é±¼
          for (let fish of this.fishes) {
            // å°è¯•åƒé£Ÿç‰©
            if (!this.tryEatFood(fish) && fish.species.diet !== "herbivore") {
              // è‚‰é£Ÿæ€§é±¼å¦‚æœæ²¡æ‰¾åˆ°é£Ÿç‰©ï¼Œå°è¯•åƒå…¶ä»–é±¼
              this.tryEatOtherFish(fish);
            }

            // æ›´æ–°è¡Œä¸º
            this.updateFishBehavior(fish, deltaTime);
          }

          // æ¸…ç†è¿‡æœŸé£Ÿç‰©
          this.cleanupFoods();

          // æ›´æ–°ç»Ÿè®¡
          this.updateStats();

          requestAnimationFrame(() => this.animate());
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateStats() {
          document.getElementById("fishCount").textContent = this.fishes.length;
          document.getElementById("foodCount").textContent = this.foods.length;

          // è®¡ç®—å¹³å‡ä½“å‹
          if (this.fishes.length > 0) {
            const totalSize = this.fishes.reduce(
              (sum, fish) => sum + fish.size,
              0
            );
            const avgSize = totalSize / this.fishes.length;
            document.getElementById("avgSize").textContent =
              avgSize.toFixed(1) + "x";
          } else {
            document.getElementById("avgSize").textContent = "0.0x";
          }

          // è®¡ç®—é£Ÿç‰©é“¾å±‚çº§
          if (this.fishes.length > 0) {
            const maxChain = Math.max(
              ...this.fishes.map((f) => f.species.foodChain)
            );
            document.getElementById("foodChainLevel").textContent = maxChain;
          }
        }

        updateFishCount() {
          document.getElementById("fishCount").textContent = this.fishes.length;
        }

        updateFoodCount() {
          document.getElementById("foodCount").textContent = this.foods.length;
        }

        // ç»‘å®šäº‹ä»¶
        bindEvents() {
          // ç‚¹å‡»æ·»åŠ é£Ÿç‰©
          document.addEventListener("click", (e) => {
            if (e.target.tagName === "BUTTON") return;
            this.addFood(e.clientX, e.clientY);
          });

          // æ‰¹é‡æ·»åŠ é£Ÿç‰©
          document
            .getElementById("addFoodBtn")
            .addEventListener("click", () => {
              for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                  this.addFood(
                    100 + Math.random() * (window.innerWidth - 200),
                    100 + Math.random() * (window.innerHeight - 200)
                  );
                }, i * 200);
              }
            });

          // æ·»åŠ é±¼
          document
            .getElementById("addFishBtn")
            .addEventListener("click", () => {
              this.addRandomFish();
            });

          // æ¸…ç†é£Ÿç‰©
          document
            .getElementById("clearFoodBtn")
            .addEventListener("click", () => {
              this.foods.forEach((food) => {
                if (food.element && food.element.parentNode) {
                  food.element.remove();
                }
              });
              this.foods = [];
              this.updateFoodCount();
            });

          // é‡ç½®ç³»ç»Ÿ
          document.getElementById("resetBtn").addEventListener("click", () => {
            this.fishes.forEach((fish) => {
              if (fish.element && fish.element.parentNode) {
                fish.element.remove();
              }
            });
            this.foods.forEach((food) => {
              if (food.element && food.element.parentNode) {
                food.element.remove();
              }
            });
            this.fishes = [];
            this.foods = [];
            this.deadFish = [];
            this.eatenCount = 0;
            this.createInitialFish(20);
          });

          // çª—å£å¤§å°è°ƒæ•´
          window.addEventListener("resize", () => {
            this.fishes.forEach((fish) => {
              fish.x = Math.max(0, Math.min(fish.x, window.innerWidth));
              fish.y = Math.max(0, Math.min(fish.y, window.innerHeight));
            });
          });
        }

        // ä»¥ä¸‹ä¸ºBoidsç®—æ³•çš„è¾…åŠ©æ–¹æ³•ï¼ˆä¸ä¹‹å‰ç‰ˆæœ¬ç›¸åŒï¼‰
        separation(fish) {
          let steerX = 0,
            steerY = 0,
            count = 0;
          for (let other of this.fishes) {
            if (other === fish) continue;
            const dx = fish.x - other.x,
              dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < this.config.visualRange * 0.4) {
              steerX += dx / distance;
              steerY += dy / distance;
              count++;
            }
          }
          if (count > 0) {
            steerX /= count;
            steerY /= count;
            const magnitude = Math.sqrt(steerX * steerX + steerY * steerY);
            if (magnitude > 0) {
              steerX = (steerX / magnitude) * this.config.maxSpeed;
              steerY = (steerY / magnitude) * this.config.maxSpeed;
              steerX -= fish.vx;
              steerY -= fish.vy;
              const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
              if (steerMag > this.config.maxForce) {
                steerX = (steerX / steerMag) * this.config.maxForce;
                steerY = (steerY / steerMag) * this.config.maxForce;
              }
            }
          }
          return { x: steerX, y: steerY };
        }

        alignment(fish) {
          let avgVx = 0,
            avgVy = 0,
            count = 0;
          for (let other of this.fishes) {
            if (other === fish) continue;
            const dx = fish.x - other.x,
              dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < this.config.visualRange) {
              avgVx += other.vx;
              avgVy += other.vy;
              count++;
            }
          }
          if (count > 0) {
            avgVx /= count;
            avgVy /= count;
            const magnitude = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
            if (magnitude > 0) {
              avgVx = (avgVx / magnitude) * this.config.maxSpeed;
              avgVy = (avgVy / magnitude) * this.config.maxSpeed;
              avgVx -= fish.vx;
              avgVy -= fish.vy;
              const steerMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
              if (steerMag > this.config.maxForce) {
                avgVx = (avgVx / steerMag) * this.config.maxForce;
                avgVy = (avgVy / steerMag) * this.config.maxForce;
              }
            }
          }
          return { x: avgVx, y: avgVy };
        }

        cohesion(fish) {
          let centerX = 0,
            centerY = 0,
            count = 0;
          for (let other of this.fishes) {
            if (other === fish) continue;
            const dx = fish.x - other.x,
              dy = fish.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0 && distance < this.config.visualRange) {
              centerX += other.x;
              centerY += other.y;
              count++;
            }
          }
          if (count > 0) {
            centerX /= count;
            centerY /= count;
            let desiredX = centerX - fish.x,
              desiredY = centerY - fish.y;
            const dist = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
            if (dist > 0) {
              desiredX = (desiredX / dist) * this.config.maxSpeed;
              desiredY = (desiredY / dist) * this.config.maxSpeed;
              desiredX -= fish.vx;
              desiredY -= fish.vy;
              const steerMag = Math.sqrt(
                desiredX * desiredX + desiredY * desiredY
              );
              if (steerMag > this.config.maxForce) {
                desiredX = (desiredX / steerMag) * this.config.maxForce;
                desiredY = (desiredY / steerMag) * this.config.maxForce;
              }
            }
            return { x: desiredX, y: desiredY };
          }
          return { x: 0, y: 0 };
        }

        foodAttraction(fish) {
          if (this.foods.length === 0) return { x: 0, y: 0 };
          let closestFood = null,
            closestDist = Infinity;
          for (let food of this.foods) {
            const dx = food.x - fish.x,
              dy = food.y - fish.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < closestDist && distance < 300) {
              closestDist = distance;
              closestFood = food;
            }
          }
          if (!closestFood) return { x: 0, y: 0 };
          let desiredX = closestFood.x - fish.x,
            desiredY = closestFood.y - fish.y;
          const dist = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
          if (dist > 0) {
            const speed = this.config.maxSpeed * Math.min(dist / 100, 1);
            desiredX = (desiredX / dist) * speed;
            desiredY = (desiredY / dist) * speed;
            desiredX -= fish.vx;
            desiredY -= fish.vy;
            const steerMag = Math.sqrt(
              desiredX * desiredX + desiredY * desiredY
            );
            if (steerMag > this.config.maxForce * 2) {
              desiredX = (desiredX / steerMag) * this.config.maxForce * 2;
              desiredY = (desiredY / steerMag) * this.config.maxForce * 2;
            }
            return { x: desiredX, y: desiredY };
          }
          return { x: 0, y: 0 };
        }

        checkBounds(fish) {
          const turnForce = this.config.edgeTurnFactor;
          let forceX = 0,
            forceY = 0;
          if (fish.x < this.config.edgeMargin) forceX = turnForce;
          else if (fish.x > window.innerWidth - this.config.edgeMargin)
            forceX = -turnForce;
          if (fish.y < this.config.edgeMargin) forceY = turnForce;
          else if (fish.y > window.innerHeight - this.config.edgeMargin)
            forceY = -turnForce;
          return { x: forceX, y: forceY };
        }
      }

      // åˆå§‹åŒ–ç”Ÿæ€ç³»ç»Ÿ
      window.addEventListener("load", () => {
        new MarineEcosystem();
      });
    </script>
  </body>
</html>
